{"question": "team_role gets the role that the subject has for the team returning undefined if the user has no explicit role for that team", "answer": "team_role(subject, team_id) = role {\n\tsubject_team := subject.teams[_]\n\tsubject_team.id == team_id\n\trole := subject_team.role\n    }"}
{"question": "check if variable x is a set containing \"foo\" and \"bar", "answer": "x == {\"foo\", \"bar\"}"}
{"question": "assign variable x to value of field foo.bar.baz in input", "answer": "x := input.foo.bar.baz"}
{"question": "check if variable x has same value as variable y", "answer": "x == y"}
{"question": "lookup value at index 0", "answer": "val := arr[0]"}
{"question": "check if value at index 0 is \"foo\"", "answer": "foo == arr[0]"}
{"question": "find all indices i that have value \"foo\"", "answer": "foo == arr[i]"}
{"question": "lookup last value", "answer": "val := arr[count(arr)-1]"}
{"question": "lookup value for key \"foo\"", "answer": "val := obj[\"foo\"]"}
{"question": "check if value for key \"foo\" is \"bar\"", "answer": "bar == obj[\"foo\"]"}
{"question": "check if key \"foo\" exists and is not false", "answer": "obj.foo"}
{"question": "check if key assigned to variable k exists", "answer": "k := \"foo\" obj[k]"}
{"question": "check if path foo.bar.baz exists and is not false", "answer": "obj.foo.bar.baz"}
{"question": "check if path foo.bar.baz foo.bar or foo does not exist or is false", "answer": "not obj.foo.bar.baz"}
{"question": "check if \"foo\" belongs to the set", "answer": "a_set[\"foo\"]"}
{"question": "check if \"foo\" DOES NOT belong to the set", "answer": "not a_set[\"foo\"]"}
{"question": "check if the array [\"a\", \"b\", \"c\"] belongs to the set", "answer": "a_set[[\"a\" ,\"b\", \"c\"]]"}
{"question": "iterate over indices i", "answer": "arr[i]"}
{"question": "iterate over values", "answer": "val := arr[_]"}
{"question": "iterate over index/value pairs", "answer": "val := arr[i]"}
{"question": "iterate over keys", "answer": "obj[key]"}
{"question": "iterate over values", "answer": "val := obj[_]"}
{"question": "iterate over key/value pairs", "answer": "val := obj[key]"}
{"question": "iterate over values", "answer": "set[val]"}
{"question": "with keywords", "answer": "some val in set"}
{"question": "nested: find key k whose bar.baz array index i is 7", "answer": "foo[k].bar.baz[i] == 7"}
{"question": "simultaneous self: find 2 keys in object foo with same value", "answer": "foo[k1] == foo[k2]; k1 != k2"}
{"question": "multiple conditions: k has same value in both conditions", "answer": "foo[k].bar.baz[i] == 7; foo[k].qux > 3"}
{"question": "assert no values in set match predicate", "answer": "count({x | set[x]; f(x)}) == 0"}
{"question": "assert all values in set make function f true", "answer": "count({x | set[x]; f(x)}) == count(set)"}
{"question": "assert no values in set make function f true (using negation and helper rule)", "answer": "not any_match"}
{"question": "assert all values in set make function f true (using negation and helper rule)s", "answer": "not any_not_match"}
{"question": "Write a Rego rule to detect if the input comes from a Kubernetes AdmissionReview object.", "answer": "package lib.konstraint.core\n\ndefault is_gatekeeper := false\n\nis_gatekeeper {\n    has_field(input, \"review\")\n    has_field(input.review, \"object\")\n}"}
{"question": "In Rego, how can you extract the actual Kubernetes object being reviewed from an AdmissionReview input?", "answer": "resource := input.review.object {\n    is_gatekeeper\n}"}
{"question": "If the input is not from an AdmissionReview, how should you assign the resource directly in Rego?", "answer": "resource := input {\n    not is_gatekeeper\n}"}
{"question": "Create a simple Rego function that formats an input message into a dictionary with a 'msg' field.", "answer": "format(msg) := {\"msg\": msg}"}
{"question": "How can you split a Kubernetes apiVersion into group and version parts in Rego?", "answer": "gv := split(api_version, \"/\")"}
{"question": "In Rego, how do you determine the group of a Kubernetes resource if apiVersion contains a '/'?", "answer": "group := gv[0] {\n    contains(api_version, \"/\")\n}"}
{"question": "In Rego, what should you set the group to if apiVersion does not contain a '/'?", "answer": "group := \"core\" {\n    not contains(api_version, \"/\")\n}"}
{"question": "How can you extract the version part of the apiVersion field from a Kubernetes object in Rego?", "answer": "version := gv[count(gv) - 1]"}
{"question": "Write a Rego helper function that checks if a given field exists in an object.", "answer": "has_field(obj, field) {\n    not object.get(obj, field, \"N_DEFINED\") == \"N_DEFINED\"\n}"}
{"question": "Create a Rego helper that checks if a field is missing or blank in an object.", "answer": "missing_field(obj, field) {\n    obj[field] == \"\"\n}\n\nmissing_field(obj, field) {\n    not has_field(obj, field)\n}"}
{"question": "How can you check if a Kubernetes object's metadata.name is missing using Rego?", "answer": "missing_field(resource.metadata, \"name\")"}
{"question": "Write a Rego rule to determine if a Kubernetes resource is missing labels.", "answer": "missing_field(resource.metadata, \"labels\")"}
{"question": "Define a Rego function to check whether a Kubernetes resource has an annotation key present.", "answer": "has_field(resource.metadata.annotations, \"<annotation-key>\")"}
{"question": "Write a Rego rule to check if a Kubernetes object has a non-empty 'kind' field.", "answer": "has_field(resource, \"kind\")"}
{"question": "How do you allow any logged-in user to read global configuration in Rego?", "answer": "allow { object.type == \"app_config\" not is_null(subject) action == read }"}
{"question": "How do you allow only admin users to write the global configuration?", "answer": "allow { object.type == \"app_config\" subject.global_role == admin action == write }"}
{"question": "What rule allows any logged-in user to read team information?", "answer": "allow { object.type == \"team\" not is_null(subject) action == read }"}
{"question": "How can an admin user write to a team object?", "answer": "allow { object.type == \"team\" subject.global_role == admin action == write }"}
{"question": "How can a user update their own user object?", "answer": "allow { object.type == \"user\" object.id == subject.id action == write }"}
{"question": "How can an admin update any user or user roles?", "answer": "allow { object.type == \"user\" subject.global_role == admin action == [write, write_role][_] }"}
{"question": "How is reading activities allowed for users?", "answer": "allow { not is_null(subject) object.type == \"activity\" action == read }"}
{"question": "How can a user access their own session in Rego?", "answer": "allow { object.type == \"session\" object.user_id == subject.id action == [read, write][_] }"}
{"question": "What allows admins to access any user's session?", "answer": "allow { object.type == \"session\" subject.global_role == admin action == [read, write][_] }"}
{"question": "How is reading enroll secrets controlled for global maintainers?", "answer": "allow { object.type == \"enroll_secret\" subject.global_role == maintainer action == read }"}
{"question": "How can team maintainers read enroll secrets?", "answer": "allow { object.type == \"enroll_secret\" team_role(subject, object.team_id) == maintainer action == read }"}
{"question": "What permission allows users to list hosts?", "answer": "allow { object.type == \"host\" not is_null(subject) action == list }"}
{"question": "How do global admins and maintainers get read/write access to hosts?", "answer": "allow { object.type == \"host\" subject.global_role = admin action == [read, write][_] } allow { object.type == \"host\" subject.global_role = maintainer action == [read, write][_] }"}
{"question": "How is a global observer allowed to read hosts?", "answer": "allow { object.type == \"host\" subject.global_role == observer action == read }"}
{"question": "How can a team maintainer or observer read a teamâ€™s hosts?", "answer": "allow { object.type == \"host\" team_role(subject, object.team_id) == maintainer action == read } allow { object.type == \"host\" team_role(subject, object.team_id) == observer action == read }"}
{"question": "Who can write labels in the system?", "answer": "allow { object.type == \"label\" subject.global_role == admin action == write } allow { object.type == \"label\" subject.global_role == maintainer action == write }"}
{"question": "How can users access queries?", "answer": "allow { not is_null(subject) object.type == \"query\" action == read }"}
{"question": "How is running a query controlled for team maintainers?", "answer": "allow { object.type == \"query\" team_role(subject, subject.teams[_].id) == maintainer action == run }"}
{"question": "How can an observer run a query if allowed?", "answer": "allow { object.type == \"query\" object.observer_can_run == true subject.global_role == observer action == run }"}
{"question": "What allows users to read targets?", "answer": "allow { not is_null(subject) object.type == \"target\" action == read }"}
{"question": "How are pack reads and writes restricted?", "answer": "allow { object.type == \"pack\" subject.global_role == admin action == [read, write][_] } allow { object.type == \"pack\" subject.global_role == maintainer action == [read, write][_] }"}
{"question": "Who can access file carves?", "answer": "allow { object.type == \"carve\" subject.global_role == admin action == [read, write][_] }"}
{"question": "Who can read and write policies in the system?", "answer": "allow { object.type == \"policy\" subject.global_role == admin action == [read, write][_] } allow { object.type == \"policy\" subject.global_role == maintainer action == [read, write][_] }"}
{"question": "How does the RBAC policy allow all actions for admins?", "answer": "allow { user_is_admin }"}
{"question": "How does the policy allow a user with the name 'bob' to perform any action?", "answer": "allow { input.user == \"bob\" }"}
{"question": "How does the policy check if a user has the right permission for an action?", "answer": "\nallow {\n    some permission\n    user_is_granted[permission]\n    input.action == permission.action\n    input.type == permission.type\n    country := data.users[input.user].location.country\n    country == \"US\"\n}\n     "}
{"question": "What condition makes a user an admin in the RBAC policy?", "answer": "\nuser_is_admin {\n    some i\n    data.users[input.user].roles[i] == \"admin\"\n}\n     "}
{"question": "How does the policy determine if a user has the 'viewer' role?", "answer": "\nuser_is_viewer {\n    some i\n    data.users[input.user].roles[i] == \"viewer\"\n}\n     "}
{"question": "What rule checks if a user has the 'guest' role?", "answer": "\nuser_is_guest {\n    some i\n    data.users[input.user].roles[i] == \"guest\"\n}\n     "}
{"question": "How does the policy define permissions granted to a user?", "answer": "\nuser_is_granted[permission] {\n    some i, j\n    role := data.users[input.user].roles[i]\n    permission := data.role_permissions[role][j]\n}\n     "}
{"question": "Allow forwarding from any host in subnet 10.0.0. to 10.0.0.2", "answer": "package network.flow\n\ndefault allow := false\n\nhost_b_ip := \"10.0.0.2\"\n\nallow if {\n    input.protocol == \"tcp\"\n    startswith(input.source_ip, \"10.0.0.\")\n    input.destination_port == 80\n    input.action == \"forward\"\n    input.forward_to == host_b_ip\n}\n\n\n"}
{"question": "Allow forwarding from any host in subnet 127.16.9. to 100.200.300.2", "answer": "package network.flow\n\ndefault allow := false\n\nhost_b_ip := \"100.200.300.2\"\n\nallow if {\n    input.protocol == \"tcp\"\n    startswith(input.source_ip, \"127.16.9.\")\n    input.destination_port == 80\n    input.action == \"forward\"\n    input.forward_to == host_b_ip\n}\n\n\n"}
{"question": "Set a default flow to drop all traffic that does not match any defined rule", "answer": "package network.flow\n\ndefault decision := \"drop\"\n\nhost_a_ip := \"10.0.0.1\"\nhost_b_ip := \"10.0.0.2\"\n\ndecision := \"forward\" if {\n    input.protocol == \"tcp\"\n    input.source_ip == host_a_ip\n    input.destination_port == 80\n    input.action == \"forward\"\n    input.forward_to == host_b_ip\n}\n"}
{"question": "Allow DNS (port 53) from a trusted subnet", "answer": "package network.flow\n\ndefault decision := \"drop\"\n\ntrusted_subnet := \"192.168.1.\"\n\ndecision := \"forward\" if {\n    input.protocol == \"udp\"\n    startswith(input.source_ip, trusted_subnet)\n    input.destination_port == 53\n    input.action == \"forward\"\n    input.forward_to != \"\"\n}\n"}
{"question": "Allow internal SSH access between two hosts", "answer": "package network.flow\n\ndefault decision := \"drop\"\n\nhost_x := \"10.1.1.10\"\nhost_y := \"10.1.1.20\"\n\n# Allow SSH traffic from X to Y\ndecision := \"forward\" if {\n    input.protocol == \"tcp\"\n    input.source_ip == host_x\n    input.destination_ip == host_y\n    input.destination_port == 22\n    input.action == \"forward\"\n}\n"}{"question": "Only allow HTTP traffic if the source IP is in an approved list.", "answer": "package network.flow\n\ndefault decision := \"drop\"\n\napproved_sources := {\"172.16.0.10\", \"172.16.0.11\"}\n\ndecision := \"forward\" if{\n    input.protocol == \"tcp\"\n    approved_sources[input.source_ip]\n    input.destination_port == 80\n    input.action == \"forward\"\n    input.forward_to != \"\"\n}\n"}
{"question": "Allow ping requests (ICMP) but only if directed to the monitoring server.", "answer": "package network.flow\n\ndefault decision := \"drop\"\n\nmonitor_ip := \"10.0.2.99\"\n\ndecision := \"forward\" if{\n    input.protocol == \"icmp\"\n    input.destination_ip == monitor_ip\n    input.icmp_type == 8  # Echo request\n    input.action == \"forward\"\n}\n"}
{"question": "Drop traffic from blacklisted MACs 00:11:22:33:44:55 and AA:BB:CC:DD:EE:FF.", "answer": "package network.flow\n\nblacklisted_macs := {\n    \"00:11:22:33:44:55\",\n    \"AA:BB:CC:DD:EE:FF\"\n}\n\n# Drop if MAC is blacklisted\ndeny if {\n    blacklisted_macs[input.source_mac]\n}\n"}
{"question": "Drop traffic from blacklisted MACs 00:11:22:33:44:55 and AA:BB:CC:DD:EE:FF. If they arnt from with the subnet 192.168.0. ", "answer": "package network.flow\n\nblacklisted_macs := {\n    \"00:11:22:33:44:55\",\n    \"AA:BB:CC:DD:EE:FF\"\n}\n\ninternal_subnet := \"192.168.0.\"\n\ndeny if{\n    blacklisted_macs[input.source_mac]\n    not startswith(input.source_ip, internal_subnet)\n}\n"}
{"question": "Drop traffic from blacklisted MACs 00:11:22:33:44:55 and AA:BB:CC:DD:EE:FF and their for the ports 22,443 ", "answer": "package network.flow\n\nblacklisted_macs := {\n    \"00:11:22:33:44:55\",\n    \"AA:BB:CC:DD:EE:FF\"\n}\n\nsensitive_ports := {22, 443}\n\ndeny if {\n    blacklisted_macs[input.source_mac]\n    sensitive_ports[input.destination_port]\n}\n"}
{"question": "What is the default behavior for access control in the RBAC policy?", "answer": "default allow = false"}
{"question": "How is the 'allow' rule determined for a user with granted permissions?", "answer": "\nallow {\n    some permission\n    user_is_granted[permission]\n    input.action == permission.action\n    input.type == permission.type\n}\n     "}
{"question": "How is the user's location used in the RBAC policy to determine access?", "answer": "\nallow {\n    some permission\n    user_is_granted[permission]\n    input.action == permission.action\n    input.type == permission.type\n    country := data.users[input.user].location.country\n    country == \"US\"\n}\n     "}
{"question": "Write a Rego rule to list all security groups by their GroupId from AWS input.", "answer": "security_groups[groupid] = obj {\n\taws.SecurityGroups[_] = obj\n\tobj.GroupId = groupid\n}"}
{"question": "Write a Rego rule that defines a threshold score for security groups.", "answer": "score_threshold = 1"}
{"question": "Create a Rego rule to compute the score for a security group if it exceeds a threshold.", "answer": "score_for_sg[sgid] = score {\n\tsecurity_groups[sgid] = obj\n\twildcard_ingress_count(obj, i)\n\twildcard_egress_count(obj, e)\n\twide_egress_count(obj, we)\n\twide_ingress_count(obj, wi)\n\tprohibited_ingress_count(obj, pi)\n\tprohibited_egress_count(obj, pe)\n\tsum([i, e, we, wi, pi, pe], score)\n\tscore > score_threshold\n}"}
{"question": "Write a Rego rule to count the number of ingress permissions with wildcards in a security group.", "answer": "wildcard_ingress_count(obj) = num {\n\twildcards = {r | x = obj.IpPermissions[r]; is_wildcard_permission(x, true)}\n\tcount(wildcards, c)\n\tnum = c * 10\n}"}
{"question": "Write a Rego rule to count the number of ingress permissions with prohibited ports in a security group.", "answer": "prohibited_ingress_count(obj) = num {\n\tprohibited = {r | x = obj.IpPermissions[r]; has_prohibited_port_open(x, true)}\n\tcount(prohibited, c)\n\tnum = c * 10\n}"}
{"question": "Write a Rego rule to count the number of ingress permissions with a wide port range.", "answer": "wide_ingress_count(obj) = num {\n\twide = {r | x = obj.IpPermissions[r]; is_broad_permission(x, true)}\n\tcount(wide, c)\n\tnum = c * 10\n}"}
{"question": "Write a Rego rule to count the number of egress permissions with a wide port range.", "answer": "wide_egress_count(obj) = num {\n\twide = {r | x = obj.IpPermissionsEgress[r]; is_broad_permission(x, true)}\n\tcount(wide, c)\n\tnum = c * 1\n}"}
{"question": "Write a Rego rule to count the number of egress permissions with wildcards.", "answer": "wildcard_egress_count(obj) = num {\n\twildcards = {r | x = obj.IpPermissionsEgress[r]; is_wildcard_permission(x, true)}\n\tcount(wildcards, c)\n\tnum = c * 1\n}"}
{"question": "Write a Rego rule to count the number of egress permissions with prohibited ports.", "answer": "prohibited_egress_count(obj) = num {\n\tprohibited = {r | x = obj.IpPermissionsEgress[r]; has_prohibited_port_open(x, true)}\n\tcount(prohibited, c)\n\tnum = c * 1\n}"}
{"question": "Write a Rego rule to check if a permission has a wildcard CIDR.", "answer": "has_wildcard_cidr(obj) {\n\tobj.IpRanges[_].CidrIp = \"0.0.0.0/0\"\n}"}
{"question": "Write a Rego rule to check if a permission has wildcard ports and protocol.", "answer": "has_wildcard_ports(obj) {\n\tobj.ToPort = null\n\tobj.FromPort = null\n\tobj.IpProtocol = \"-1\"\n}"}
{"question": "Write a Rego rule to check if a security group permission has a wide port range.", "answer": "has_wide_range(obj) {\n\tobj.ToPort != null\n\tobj.FromPort != null\n\tx = obj.ToPort - obj.FromPort\n\tx > 0\n}"}
{"question": "Write a Rego rule to check if a permission allows all traffic on all ports.", "answer": "is_wildcard_permission(obj) {\n\thas_wildcard_ports(obj, true)\n\thas_wildcard_cidr(obj, true)\n}"}
{"question": "Write a Rego rule to check if a permission allows a very wide range of traffic.", "answer": "is_broad_permission(obj) {\n\thas_wide_range(obj, true)\n\thas_wildcard_cidr(obj, true)\n}"}
{"question": "Define a set in Rego that represents keys for ingress and egress permissions.", "answer": "ipperm_key = {\"IpPermissions\", \"IpPermissionsEgress\"}"}
{"question": "Write a Rego rule to check if prohibited ports are open in a security group.", "answer": "has_prohibited_port_open(obj) {\n\tfrom = obj[perm_key][j].FromPort\n\tto = obj[perm_key][j].ToPort\n\tipperm_key[perm_key]\n\tbad_ports[port]\n\tfrom <= port\n\tport <= to\n}"}
{"question": "Define a set of prohibited ports in Rego.", "answer": "bad_ports = {23, 69, 87, 111, 21}"}
{"question": "Write a Rego rule that identifies Docker containers violating both whitelist and blacklist rules for host volume paths.", "answer": "violates_volume_mapping_policy {\n\tnot valid_volume_mapping_whitelist\n\tnot valid_volume_mapping_blacklist\n}"}
{"question": "Write a Rego rule that returns all forbidden volume paths mapped by a Docker container.", "answer": "forbidden_paths[host_path] {\n\tpaths = host_volume_paths(input.Body.HostConfig)\n\tpaths[host_path]\n\tstartswith(host_path, invalid_host_path_prefixes[_])\n}"}
{"question": "Write a Rego rule to validate that Docker volume mappings only use a strict subset of allowed prefixes.", "answer": "strictly_allowed_volume_mappings {\n\tpaths = host_volume_paths(input.Body.HostConfig)\n\tall path in paths {\n\t\tstartswith(path, valid_host_path_prefixes[_])\n\t}\n}"}
{"question": "Write a Rego rule that checks if all host volume paths in a Docker container are whitelisted.", "answer": "valid_volume_mapping_whitelist {\n\tpaths = host_volume_paths(input.Body.HostConfig)\n\tinvalid_paths = paths - valid_host_volume_paths\n\tcount(invalid_paths, 0)\n}"}
{"question": "Write a Rego rule that checks if no blacklisted host volume paths are used in a Docker container.", "answer": "valid_volume_mapping_blacklist {\n\tpaths = host_volume_paths(input.Body.HostConfig)\n\tinvalid_paths = paths & invalid_host_volume_paths\n\tcount(invalid_paths, 0)\n}"}
{"question": "Write a Rego rule to define valid host volume paths based on allowed prefixes.", "answer": "valid_host_volume_paths[host_path] {\n\tpaths = host_volume_paths(input.Body.HostConfig)\n\tpaths[host_path]\n\tstartswith(host_path, valid_host_path_prefixes[_])\n}"}
{"question": "Write a Rego rule to define invalid host volume paths based on forbidden prefixes.", "answer": "invalid_host_volume_paths[host_path] {\n\tpaths = host_volume_paths(input.Body.HostConfig)\n\tpaths[host_path]\n\tstartswith(host_path, invalid_host_path_prefixes[_])\n}"}
{"question": "Define a Rego set of allowed prefixes for valid host volume paths.", "answer": "valid_host_path_prefixes = {\"allowed\", \"also/allowed\"}"}
{"question": "Define a Rego set of forbidden prefixes for invalid host volume paths.", "answer": "invalid_host_path_prefixes = {\"forbidden\", \"also/forbidden\"}"}
{"question": "Write a Rego rule that validates a Docker container only if it has at least one valid volume mapping and zero forbidden mappings.", "answer": "valid_container_with_required_mapping {\n\tpaths = host_volume_paths(input.Body.HostConfig)\n\tsome path\n\tpaths[path]\n\tstartswith(path, valid_host_path_prefixes[_])\n\tinvalid = paths & invalid_host_volume_paths\n\tcount(invalid, 0)\n}"}
{"question": "Write a Rego rule to identify Docker containers that map both an allowed and a forbidden host volume path.", "answer": "mixed_allowed_forbidden_paths {\n\tpaths = host_volume_paths(input.Body.HostConfig)\n\tsome path1\n\tpaths[path1]\n\tstartswith(path1, valid_host_path_prefixes[_])\n\tsome path2\n\tpaths[path2]\n\tstartswith(path2, invalid_host_path_prefixes[_])\n}"}
{"question": "Write a Rego rule that flags Docker containers with forbidden host paths unless they also have at least two allowed host paths.", "answer": "forbidden_unless_multiple_allowed {\n\tpaths = host_volume_paths(input.Body.HostConfig)\n\tforbidden = {path | paths[path]; startswith(path, invalid_host_path_prefixes[_])}\n\tallowed = {path | paths[path]; startswith(path, valid_host_path_prefixes[_])}\n\tcount(forbidden, f)\n\tcount(allowed, a)\n\tf > 0\n\ta < 2\n}"}
{"question": "Write a Rego rule that asserts no Docker container may mount a forbidden volume if it uses more than 3 volumes in total.", "answer": "deny_forbidden_when_many_volumes {\n\tpaths = host_volume_paths(input.Body.HostConfig)\n\tcount(paths, total)\n\ttotal > 3\n\tforbidden = paths & invalid_host_volume_paths\n\tcount(forbidden, f)\n\tf > 0\n}"}
{"question": "Write a Rego rule that allows only containers where all volume paths match at least one allowed prefix and none match a forbidden prefix.", "answer": "strict_whitelist_no_blacklist {\n\tpaths = host_volume_paths(input.Body.HostConfig)\n\tall path in paths {\n\t\tstartswith(path, valid_host_path_prefixes[_])\n\t}\n\tinvalid = paths & invalid_host_volume_paths\n\tcount(invalid, 0)\n}"}
{"question": "Write a Rego rule that computes a risk score for a Docker container where each forbidden path adds 5 points and each missing allowed path adds 2 points.", "answer": "volume_mapping_risk_score[score] {\n\tpaths = host_volume_paths(input.Body.HostConfig)\n\tforbidden = {path | paths[path]; startswith(path, invalid_host_path_prefixes[_])}\n\tmissing_allowed = {path | paths[path]; not startswith(path, valid_host_path_prefixes[_])}\n\tcount(forbidden, f)\n\tcount(missing_allowed, m)\n\tscore = f * 5 + m * 2\n}"}
{"question": "Write a Rego rule that returns true if Docker container's volume mappings only use paths beginning with 'allowed'.", "answer": "only_allowed_prefix_used {\n\tpaths = host_volume_paths(input.Body.HostConfig)\n\tall path in paths {\n\t\tstartswith(path, \"allowed\")\n\t}\n}"}
{"question": "Write an OPA policy that ensures public servers do not expose the HTTP protocol.", "answer": "package example\n\nallow if {\n    count(violation) == 0\n}\n\nviolation contains server.id if {\n    some server in public_servers\n    \"http\" in server.protocols\n}\n\npublic_servers contains server if {\n    some server in input.servers\n    some port in server.ports\n    some input_port in input.ports\n    port == input_port.id\n    some input_network in input.networks\n    input_port.network == input_network.id\n    input_network.public\n}"}
{"question": "Allow all http traffic from 10.0.0.1 to 10.0.0.2", "answer": "package network.flow\n\ndefault allow := false\n\n# Define host IPs\nhost_a_ip := \"10.0.0.1\"\nhost_b_ip := \"10.0.0.2\"\n\nallow if {\n    input.protocol == \"tcp\"\n    input.source_ip == host_a_ip\n    input.destination_port == 80\n    input.action == \"forward\"\n    input.forward_to == host_b_ip\n}\n"}
{"question": "Generate a Rego policy that blocks public servers from using HTTP.", "answer": "package example\n\nallow if {\n    count(violation) == 0\n}\n\nviolation contains server.id if {\n    some server in public_servers\n    \"http\" in server.protocols\n}\n\npublic_servers contains server if {\n    some server in input.servers\n    some port in server.ports\n    some input_port in input.ports\n    port == input_port.id\n    some input_network in input.networks\n    input_port.network == input_network.id\n    input_network.public\n}"}
{"question": "Create an OPA policy that forbids 'telnet' protocol exposure on any server.", "answer": "package example\n\nallow if {\n    count(violation) == 0\n}\n\nviolation contains server.id if {\n    some server in input.servers\n    \"telnet\" in server.protocols\n}"}
{"question": "How would you write a Rego policy that prevents servers from offering the insecure telnet service?", "answer": "package example\n\nallow if {\n    count(violation) == 0\n}\n\nviolation contains server.id if {\n    some server in input.servers\n    \"telnet\" in server.protocols\n}"}
{"question": "Write a full policy that ensures no server in public networks exposes HTTP or any server exposes telnet.", "answer": "package example\n\nallow if {\n    count(violation) == 0\n}\n\nviolation contains server.id if {\n    some server in public_servers\n    \"http\" in server.protocols\n}\n\nviolation contains server.id if {\n    some server in input.servers\n    \"telnet\" in server.protocols\n}\n\npublic_servers contains server if {\n    some server in input.servers\n    some port in server.ports\n    some input_port in input.ports\n    port == input_port.id\n    some input_network in input.networks\n    input_port.network == input_network.id\n    input_network.public\n}"}
{"question": "Prevent exposure of HTTP on public servers and telnet anywhere, using a Rego policy.", "answer": "package example\n\nallow if {\n    count(violation) == 0\n}\n\nviolation contains server.id if {\n    some server in public_servers\n    \"http\" in server.protocols\n}\n\nviolation contains server.id if {\n    some server in input.servers\n    \"telnet\" in server.protocols\n}\n\npublic_servers contains server if {\n    some server in input.servers\n    some port in server.ports\n    some input_port in input.ports\n    port == input_port.id\n    some input_network in input.networks\n    input_port.network == input_network.id\n    input_network.public\n}"}
{"question": "How to write an OPA policy that identifies violations when telnet or http are available in wrong places?", "answer": "package example\n\nallow if {\n    count(violation) == 0\n}\n\nviolation contains server.id if {\n    some server in public_servers\n    \"http\" in server.protocols\n}\n\nviolation contains server.id if {\n    some server in input.servers\n    \"telnet\" in server.protocols\n}\n\npublic_servers contains server if {\n    some server in input.servers\n    some port in server.ports\n    some input_port in input.ports\n    port == input_port.id\n    some input_network in input.networks\n    input_port.network == input_network.id\n    input_network.public\n}"}
{"question": "Generate a rego snippet that bans insecure protocols like 'telnet' or 'http' depending on server exposure.", "answer": "package example\n\nallow if {\n    count(violation) == 0\n}\n\nviolation contains server.id if {\n    some server in public_servers\n    \"http\" in server.protocols\n}\n\nviolation contains server.id if {\n    some server in input.servers\n    \"telnet\" in server.protocols\n}\n\npublic_servers contains server if {\n    some server in input.servers\n    some port in server.ports\n    some input_port in input.ports\n    port == input_port.id\n    some input_network in input.networks\n    input_port.network == input_network.id\n    input_network.public\n}"}
{"question": "Create a Rego policy that checks if age is 18 or older and defines pi constant.", "answer": "package validate.age_check\n\npi := 3.14\n\nis_adult := true {\n  input.age >= 18\n}\n\ntest_pi_constant {\n  pi == 3.14\n}\n\ntest_adult_rule {\n  is_adult with input as {\"age\": 21}\n  not is_adult with input as {\"age\": 16}\n}"}
{"question": "OPA policy: define pi and allow users based on their age >= 18.", "answer": "package math_and_access\n\npi_value := 3.14\n\naccess_granted := true {\n  input.age >= 18\n}\n\ntest_pi_value_correct {\n  pi_value == 3.14\n}\n\ntest_access_rule {\n  access_granted with input as {\"age\": 25}\n  not access_granted with input as {\"age\": 12}\n}"}
{"question": "Write a policy to define a pi constant and allow adults only.", "answer": "package constants.age_policy\n\npi_const := 3.14\n\nis_allowed := true {\n  input.age >= 18\n}\n\ntest_pi_equals_314 {\n  pi_const == 3.14\n}\n\ntest_is_allowed_behavior {\n  is_allowed with input as {\"age\": 30}\n  not is_allowed with input as {\"age\": 15}\n}"}
{"question": "OPA substring test to get 'foo' from 'foobar'.", "answer": "package substring_tests\n\ntest_get_foo {\n  substring(\"foobar\", 0, 3) == \"foo\"\n}"}
{"question": "Format a list of tasks using sprintf in Rego.", "answer": "package task_formatter\n\ntest_task_list_format {\n  sprintf(\"Pending tasks: %v\", [[\"task1\", \"task2\"]]) == \"Pending tasks: [\\\"task1\\\", \\\"task2\\\"]\"\n}"}
{"question": "Uppercase a lowercase string using OPA built-ins.", "answer": "package string_uppercase\n\ntest_uppercase_transform {\n  upper(\"openpolicy\", \"OPENPOLICY\")\n}"}
{"question": "Split a path and select the second folder name.", "answer": "package path_splitter\n\ntest_path_folder_extract {\n  split(\"/home/user/documents\", \"/\", parts)\n  parts[2] == \"user\"\n}"}
{"question": "Write a Rego policy to validate string counting and substring extraction.", "answer": "package mixed_string_ops\n\ntest_string_operations {\n  count(\"open ai\") == 7\n  substring(\"openai\", 4, 2) == \"ai\"\n}"}
{"question": "OPA Rego: Lowercase function check for mixed case input.", "answer": "package mixed_case_lowering\n\ntest_lowercase_conversion {\n  lower(\"OpenAI\", \"openai\")\n}"}
{"question": "Write a Rego rule to calculate the absolute value of a number.", "answer": "package number_tests\n\ntest_abs {\n  abs(1) == 1\n  abs(-2) == 2\n  abs(0) == 0\n}"}
{"question": "Create a Rego rule that rounds a floating point number upwards.", "answer": "package rounding_tests\n\ntest_ceil {\n  ceil(1) == 1\n  ceil(1.2) == 2\n}"}
{"question": "Write a Rego rule that computes the floor of floating point numbers.", "answer": "package rounding_tests\n\ntest_floor {\n  floor(1) == 1\n  floor(1.2) == 1\n}"}
{"question": "Write a Rego rule that rounds floating point numbers to the nearest integer.", "answer": "package rounding_tests\n\ntest_round {\n  round(1) == 1\n  round(1.2) == 1\n  round(1.6) == 2\n}"}
{"question": "Generate a Rego rule that produces a range of numbers between two values.", "answer": "package numbers_tests\n\ntest_numbers_range {\n  numbers.range(1, 1) == [1]\n  numbers.range(1, 5) == [1, 2, 3, 4, 5]\n  numbers.range(5, 1) == [5, 4, 3, 2, 1]\n  numbers.range(5, 4) == [5, 4]\n}"}
{"question": "Write a Rego rule that performs a bitwise OR operation between two numbers.", "answer": "package bitwise_tests\n\ntest_bits_or {\n  bits.or(1, 1) == 1\n  bits.or(2, 5) == 7\n  bits.or(10, 101) == 111\n}"}
{"question": "Create a Rego rule that performs a bitwise AND operation between two numbers.", "answer": "package bitwise_tests\n\ntest_bits_and {\n  bits.and(1, 1) == 1\n  bits.and(2, 10) == 2\n  bits.and(10, 111) == 10\n  bits.and(1, 2) == 0\n}"}
{"question": "Write a Rego rule to perform a bitwise XOR operation on numbers.", "answer": "package bitwise_tests\n\ntest_bits_xor {\n  bits.xor(1, 1) == 0\n  bits.xor(8, 24) == 16\n  bits.xor(10, 102) == 108\n}"}
{"question": "Implement a Rego rule that left-shifts a number by a given number of bits.", "answer": "package bitwise_tests\n\ntest_bits_lsh {\n  bits.lsh(1, 0) == 1\n  bits.lsh(1, 1) == 2\n  bits.lsh(8, 24) == 134217728\n}"}
{"question": "Create a Rego rule that right-shifts a number by a given number of bits.", "answer": "package bitwise_tests\n\ntest_bits_rsh {\n  bits.rsh(1, 0) == 1\n  bits.rsh(1, 1) == 0\n  bits.rsh(24, 2) == 6\n}"}
{"question": "Write a Rego rule that negates all the bits in a number.", "answer": "package bitwise_tests\n\ntest_bits_negate {\n  bits.negate(1) == -2\n  bits.negate(2) == -3\n  bits.negate(-10) == 9\n}"}
{"question": "Write a Rego policy that collects all hostnames from a nested sites structure.", "answer": "package fregot.tests.how_do_i_write_policies\n\nhostnames[name] { sites[_].servers[_].hostname = name }\n\ntest_hostnames { hostnames[\"hydrogen\"] }"}
{"question": "Define a Rego rule that maps server hostnames to their associated applications.", "answer": "package fregot.tests.how_do_i_write_policies\n\napps_by_hostname[hostname] = app {\n    sites[_].servers[_] = server\n    server.hostname = hostname\n    apps[i].servers[_] = server.name\n    apps[i].name = app\n}\n\ntest_apps_by_hostname {\n    app = apps_by_hostname[\"helium\"]\n    app == \"web\"\n}"}
{"question": "Create a Rego rule that generates instances from both servers and containers, ensuring all have an address and name.", "answer": "package fregot.tests.how_do_i_write_policies\n\ninstances[instance] {\n    sites[_].servers[_] = server\n    instance = {\"address\": server.hostname, \"name\": server.name}\n}\n\ninstances[instance] {\n    containers[_] = container\n    instance = {\"address\": container.ipaddress, \"name\": container.name}\n}\n\ntest_instances {\n    instances[x]\n    x == {\"address\": \"hydrogen\", \"name\": \"web-0\"}\n}"}
{"question": "Define a Rego policy where a user's memory limit depends on their membership in a group of power users or restricted users.", "answer": "package fregot.tests.how_do_i_write_policies\n\nuser = \"alice\"\n\npower_users = {\"alice\", \"bob\", \"fred\"}\nrestricted_users = {\"bob\", \"kim\"}\n\nmax_memory = 32 { power_users[user] }\nmax_memory = 4 { restricted_users[user] }\n\ntest_max_memory { max_memory == 32 }"}
{"question": "Write a Rego rule to find applications that are deployed on the same site as the MySQL application.", "answer": "package fregot.tests.how_do_i_write_policies\n\nsame_site[apps[k].name] = apps[k].name {\n    apps[i].name = \"mysql\"\n    apps[i].servers[_] = server\n    sites[j].servers[_].name = server\n    sites[j].servers[_].name = other_server\n    server != other_server\n    apps[k].servers[_] = other_server\n}\n\ntest_same_site {\n    same_site[\"web\"]\n}"}
{"question": "Using an array comprehension, create a list of site names for all sites in a specific region.", "answer": "package fregot.tests.how_do_i_write_policies\n\ntest_array_comprehensions {\n    region = \"west\"\n    west_names = [name | sites[i].region = region; sites[i].name = name]\n    west_names == [\"smoke\", \"dev\"]\n}"}
{"question": "Create an object comprehension that maps app names to a list of hostnames where they run.", "answer": "package fregot.tests.how_do_i_write_policies\n\napp_to_hostnames = {app.name: app_hostnames |\n    apps[_] = app\n    app_hostnames = [hostname |\n        name = app.servers[_]\n        sites[_].servers[_] = s\n        s.name = name\n        hostname = s.hostname]\n}\n\ntest_app_to_hostnames {\n    app_to_hostnames[\"web\"] == [\"hydrogen\", \"helium\", \"beryllium\", \"boron\", \"nitrogen\"]\n    app_to_hostnames[\"mysql\"] == [\"lithium\", \"carbon\"]\n    app_to_hostnames[\"mongodb\"] == [\"oxygen\"]\n}"}
{"question": "Write a Rego policy that deduplicates elements of an array using a set comprehension.", "answer": "package fregot.tests.how_do_i_write_policies\n\nset_comprehension_a = [1, 2, 3, 4, 3, 4, 3, 4, 5]\n\nset_comprehension_b = {x | x = set_comprehension_a[_]}\n\ntest_set_comprehension_b { set_comprehension_b == {1, 2, 3, 4, 5} }"}
{"question": "Create a Rego function that trims whitespace and splits a string by a dot ('.') character.", "answer": "package fregot.tests.how_do_i_write_policies\n\ntrim_and_split(s) = x {\n    trim(s, \" \", t)\n    split(t, \".\", x)\n}\n\ntest_trim_and_split {\n    x := trim_and_split(\"   foo.bar \")\n    x == [\"foo\", \"bar\"]\n}"}
{"question": "Write Rego rules to identify applications that are deployed in a production site and those that are not.", "answer": "package fregot.tests.how_do_i_write_policies\n\nprod_servers[name] = name {\n    sites[_] = site\n    site.name = \"prod\"\n    site.servers[_].name = name\n}\n\napps_in_prod[name] = name {\n    apps[_] = app\n    app.servers[_] = server\n    app.name = name\n    prod_servers[server]\n}\n\napps_not_in_prod[name] = name {\n    apps[_].name = name\n    not apps_in_prod[name]\n}\n\ntest_apps_in_prod {\n    apps_in_prod[\"web\"]\n    apps_in_prod[\"mysql\"]\n}"}
{"question": "How do you match strings that start with a prefix in Rego?", "answer": "startswith(value, \"ami-\")"}
{"question": "In Rego, how do you negate a membership check in a set?", "answer": "not approved_amis[ami]"}
{"question": "How can you select each item from a list in Rego?", "answer": "input.resource_changes[_]"}
{"question": "How do you use 'with' in Rego tests to override input data?", "answer": "test_name {\n    rule with input as mock_input\n}"}
{"question": "How do you define a default value for a rule in Rego?", "answer": "default allow = false"}
{"question": "What is the condition for allowing all AMIs in this Rego policy?", "answer": "allow if { count(unapproved_amis) == 0 }"}
{"question": "What function checks the number of unapproved AMIs is zero?", "answer": "allow if{ count(unapproved_amis) == 0 }"}
{"question": "Allow all http traffic from 10.0.0.1 to 10.0.0.2", "answer": "package network.flow\n\ndefault allow := false\n\n# Define host IPs\nhost_a_ip := \"10.0.0.1\"\nhost_b_ip := \"10.0.0.2\"\n\nallow if {\n    input.protocol == \"tcp\"\n    input.source_ip == host_a_ip\n    input.destination_port == 80\n    input.action == \"forward\"\n    input.forward_to == host_b_ip\n}\n"}
{"question": "Deny all http traffic from 10.0.0.1 except from 10.0.0.2", "answer": "package network.flow\n\ndefault allow := false\n\nhost_a_ip := \"10.0.0.1\"\nhost_b_ip := \"10.0.0.2\"\n\nallow if{\n    input.protocol == \"tcp\"\n    input.source_ip == host_a_ip\n    input.destination_port == 80\n    input.action == \"forward\"\n    input.forward_to == host_b_ip\n}\n\ndeny if{\n    input.protocol == \"tcp\"\n    input.source_ip == host_a_ip\n    input.destination_port == 80\n    input.action == \"forward\"\n    input.forward_to != host_b_ip\n}\n\n"}
{"question": "Deny all traffic on port 4000 from 10.0.0.1 except from 10.0.0.2", "answer": "package network.flow\n\ndefault allow := false\n\nhost_a_ip := \"10.0.0.1\"\nhost_b_ip := \"10.0.0.2\"\n\nallow if{\n    input.protocol == \"tcp\"\n    input.source_ip == host_a_ip\n    input.destination_port == 4000\n    input.action == \"forward\"\n    input.forward_to == host_b_ip\n}\n\ndeny if{\n    input.protocol == \"tcp\"\n    input.source_ip == host_a_ip\n    input.destination_port == 4000\n    input.action == \"forward\"\n    input.forward_to != host_b_ip\n}\n\n"}
{"question": "Allow forwarding from any host in subnet 10.0.0. to 10.0.0.2", "answer": "package network.flow\n\ndefault allow := false\n\nhost_b_ip := \"10.0.0.2\"\n\nallow if {\n    input.protocol == \"tcp\"\n    startswith(input.source_ip, \"10.0.0.\")\n    input.destination_port == 80\n    input.action == \"forward\"\n    input.forward_to == host_b_ip\n}\n\n\n"}
{"question": "Allow forwarding from any host in subnet 127.16.9. to 100.200.300.2", "answer": "package network.flow\n\ndefault allow := false\n\nhost_b_ip := \"100.200.300.2\"\n\nallow if {\n    input.protocol == \"tcp\"\n    startswith(input.source_ip, \"127.16.9.\")\n    input.destination_port == 80\n    input.action == \"forward\"\n    input.forward_to == host_b_ip\n}\n\n\n"}
{"question": "Set a default flow to drop all traffic that does not match any defined rule", "answer": "package network.flow\n\ndefault decision := \"drop\"\n\nhost_a_ip := \"10.0.0.1\"\nhost_b_ip := \"10.0.0.2\"\n\ndecision := \"forward\" if {\n    input.protocol == \"tcp\"\n    input.source_ip == host_a_ip\n    input.destination_port == 80\n    input.action == \"forward\"\n    input.forward_to == host_b_ip\n}\n"}
{"question": "Allow DNS (port 53) from a trusted subnet", "answer": "package network.flow\n\ndefault decision := \"drop\"\n\ntrusted_subnet := \"192.168.1.\"\n\ndecision := \"forward\" if {\n    input.protocol == \"udp\"\n    startswith(input.source_ip, trusted_subnet)\n    input.destination_port == 53\n    input.action == \"forward\"\n    input.forward_to != \"\"\n}\n"}
{"question": "Allow internal SSH access between two hosts", "answer": "package network.flow\n\ndefault decision := \"drop\"\n\nhost_x := \"10.1.1.10\"\nhost_y := \"10.1.1.20\"\n\n# Allow SSH traffic from X to Y\ndecision := \"forward\" if {\n    input.protocol == \"tcp\"\n    input.source_ip == host_x\n    input.destination_ip == host_y\n    input.destination_port == 22\n    input.action == \"forward\"\n}\n"}{"question": "Only allow HTTP traffic if the source IP is in an approved list.", "answer": "package network.flow\n\ndefault decision := \"drop\"\n\napproved_sources := {\"172.16.0.10\", \"172.16.0.11\"}\n\ndecision := \"forward\" if{\n    input.protocol == \"tcp\"\n    approved_sources[input.source_ip]\n    input.destination_port == 80\n    input.action == \"forward\"\n    input.forward_to != \"\"\n}\n"}
{"question": "Allow ping requests (ICMP) but only if directed to the monitoring server.", "answer": "package network.flow\n\ndefault decision := \"drop\"\n\nmonitor_ip := \"10.0.2.99\"\n\ndecision := \"forward\" if{\n    input.protocol == \"icmp\"\n    input.destination_ip == monitor_ip\n    input.icmp_type == 8  # Echo request\n    input.action == \"forward\"\n}\n"}
{"question": "Drop traffic from blacklisted MACs 00:11:22:33:44:55 and AA:BB:CC:DD:EE:FF.", "answer": "package network.flow\n\nblacklisted_macs := {\n    \"00:11:22:33:44:55\",\n    \"AA:BB:CC:DD:EE:FF\"\n}\n\n# Drop if MAC is blacklisted\ndeny if {\n    blacklisted_macs[input.source_mac]\n}\n"}
{"question": "Drop traffic from blacklisted MACs 00:11:22:33:44:55 and AA:BB:CC:DD:EE:FF. If they arnt from with the subnet 192.168.0. ", "answer": "package network.flow\n\nblacklisted_macs := {\n    \"00:11:22:33:44:55\",\n    \"AA:BB:CC:DD:EE:FF\"\n}\n\ninternal_subnet := \"192.168.0.\"\n\ndeny if{\n    blacklisted_macs[input.source_mac]\n    not startswith(input.source_ip, internal_subnet)\n}\n"}
{"question": "Drop traffic from blacklisted MACs 00:11:22:33:44:55 and AA:BB:CC:DD:EE:FF and their for the ports 22,443 ", "answer": "package network.flow\n\nblacklisted_macs := {\n    \"00:11:22:33:44:55\",\n    \"AA:BB:CC:DD:EE:FF\"\n}\n\nsensitive_ports := {22, 443}\n\ndeny if {\n    blacklisted_macs[input.source_mac]\n    sensitive_ports[input.destination_port]\n}\n"}
{"question": "Install a flow that allows only TCP traffic and drops all other protocols", "answer": "package network.flow\n\ndefault decision := \"drop\"\n\ndecision := \"forward\" if {\n    input.protocol == \"tcp\"\n    input.action == \"forward\"\n}\n\n"}
{"question": "Detect and block traffic spikes by dropping flows exceeding a packet rate threshold", "answer": "package network.flow\n\ndefault decision := \"forward\"\n\nmax_packet_rate := 1000  # packets per second\n\ndecision := \"drop\" if {\n    input.packet_rate > max_packet_rate\n}\n\n\n"}
{"question": "Allow ARP packets to flood across all ports to enable address resolution", "answer": "package network.flow\n\ndefault decision := \"drop\"\n\ndecision := \"flood\" if {\n    input.protocol == \"arp\"\n    input.action == \"flood\"\n}\n\n\n"}
{"question": "Allow DHCP traffic (ports 67 and 68) only from authorized MAC addresses", "answer": "package network.flow\n\ndefault decision := \"drop\"\n\nauthorized_macs := {\"00:11:22:33:44:55\", \"66:77:88:99:AA:BB\"}\n\ndecision := \"forward\" if {\n    input.protocol == \"udp\"\n    input.source_mac == mac\n    authorized_macs[mac]\n    input.destination_port == 67\n    input.source_port == 68\n    input.action == \"forward\"\n}"}
{"question": "Install a flow that allows only TCP traffic and drops all other protocols", "answer": "package network.flow\n\ndefault allow := false\n\nallow if {\n    input.protocol == \"tcp\"\n}\n"}
{"question": "Install a flow that allows only TCP traffic and drops all other protocols", "answer": "package network.flow\n\ndefault decision := \"drop\"\n\ndecision := \"forward\" if {\n    input.protocol == \"tcp\"\n    input.action == \"forward\"\n    input.source_ip != \"\"  # ensure valid input\n}\n\n"}
{"question": "Detect and block traffic spikes by dropping flows exceeding a packet rate threshold", "answer": "package network.flow\n\ndefault decision := \"forward\"\n\nthreshold := 1000\n\ndecision := \"drop\" if {\n    input.packet_rate > threshold\n}\n"}
{"question": "Allow ARP packets to flood across all ports to enable address resolution", "answer": "package network.flow\n\ndefault decision := \"drop\"\n\ndecision := \"flood\" if {\n    input.ethertype == \"arp\"\n}\n\n"}
{"question": "Allow ARP packets to flood across all ports to enable address resolution", "answer": "package network.flow\n\ndefault decision := \"drop\"\n\ndecision := \"flood\" if {\n    input.protocol == \"arp\"\n    input.action == \"flood\"\n}\n"}
